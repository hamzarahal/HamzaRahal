{
  "hash": "233584afd231990125120c3c198b3fb8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Clustering Heart Disease Patient Data\"\nformat:\n  html:\n    code-fold: true\nexecute:\n  echo: true\nauthor: \"Hamza Rahal\"\ndate: \"2024-06-06\"\ncategories: [project, code, analysis]\n---\n\n\n## 1. Targeting treatment for heart disease patients\n\nClustering algorithms are used to group together items that are similar to one another. There are many industries where it would be beneficial and insightful to use an unsupervised learning algorithm - retailers want to group similar customers for targeted ad campaigns, biologists want to find plants that share similar characteristics, and more. We are going to explore if it would be appropriate to use some clustering algorithms to group medical patients.\n\nWe are going to look at anonymized patients who have been diagnosed with heart disease. Patients with similar characteristics might respond to the same treatments, and doctors would benefit from learning about the outcomes of patients similar to those they are treating. The data we are analyzing comes from the V.A. Medical Center in Long Beach, CA. For more information, see [here](http://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/heart-disease.names).\n\nBefore beginning a project, it is important to get an idea of what the patient data looks like. In addition, the clustering algorithms used below require that the data be numeric, so it is necessary to ensure the patient data doesn't need any transformations. You will also be brushing up on your base R skills for some analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# loading the data\nheart_disease = read.csv(\"heart_disease_patients.csv\")\n\n# print the first ten rows of the data set\nhead(heart_disease, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   id age sex cp trestbps chol fbs restecg thalach exang oldpeak slope\n1   1  63   1  1      145  233   1       2     150     0     2.3     3\n2   2  67   1  4      160  286   0       2     108     1     1.5     2\n3   3  67   1  4      120  229   0       2     129     1     2.6     2\n4   4  37   1  3      130  250   0       0     187     0     3.5     3\n5   5  41   0  2      130  204   0       2     172     0     1.4     1\n6   6  56   1  2      120  236   0       0     178     0     0.8     1\n7   7  62   0  4      140  268   0       2     160     0     3.6     3\n8   8  57   0  4      120  354   0       0     163     1     0.6     1\n9   9  63   1  4      130  254   0       2     147     0     1.4     2\n10 10  53   1  4      140  203   1       2     155     1     3.1     3\n```\n\n\n:::\n\n```{.r .cell-code}\n# check that only numeric variables\nlapply(heart_disease, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$id\n[1] \"integer\"\n\n$age\n[1] \"integer\"\n\n$sex\n[1] \"integer\"\n\n$cp\n[1] \"integer\"\n\n$trestbps\n[1] \"integer\"\n\n$chol\n[1] \"integer\"\n\n$fbs\n[1] \"integer\"\n\n$restecg\n[1] \"integer\"\n\n$thalach\n[1] \"integer\"\n\n$exang\n[1] \"integer\"\n\n$oldpeak\n[1] \"numeric\"\n\n$slope\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n## 2. Quantifying patient differences\n\nIt is important to conduct some exploratory data analysis to familiarize ourselves with the data before clustering. This will help us learn more about the variables and make an informed decision about whether we should scale the data. Because k-means and hierarchical clustering measures similarity between points using a distance formula, it can place extra emphasis on certain variables that have a larger scale and thus larger differences between points.\n\nExploratory data analysis helps us to understand the characteristics of the patients in the data. We need to get an idea of the value ranges of the variables and their distributions. This will also be helpful when we evaluate the clusters of patients from the algorithms. Are there more patients of one gender? What might an outlier look like?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# evidence that the data should be scaled?\nsummary(heart_disease)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       id             age             sex               cp       \n Min.   :  1.0   Min.   :29.00   Min.   :0.0000   Min.   :1.000  \n 1st Qu.: 76.5   1st Qu.:48.00   1st Qu.:0.0000   1st Qu.:3.000  \n Median :152.0   Median :56.00   Median :1.0000   Median :3.000  \n Mean   :152.0   Mean   :54.44   Mean   :0.6799   Mean   :3.158  \n 3rd Qu.:227.5   3rd Qu.:61.00   3rd Qu.:1.0000   3rd Qu.:4.000  \n Max.   :303.0   Max.   :77.00   Max.   :1.0000   Max.   :4.000  \n    trestbps          chol            fbs            restecg      \n Min.   : 94.0   Min.   :126.0   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:120.0   1st Qu.:211.0   1st Qu.:0.0000   1st Qu.:0.0000  \n Median :130.0   Median :241.0   Median :0.0000   Median :1.0000  \n Mean   :131.7   Mean   :246.7   Mean   :0.1485   Mean   :0.9901  \n 3rd Qu.:140.0   3rd Qu.:275.0   3rd Qu.:0.0000   3rd Qu.:2.0000  \n Max.   :200.0   Max.   :564.0   Max.   :1.0000   Max.   :2.0000  \n    thalach          exang           oldpeak         slope      \n Min.   : 71.0   Min.   :0.0000   Min.   :0.00   Min.   :1.000  \n 1st Qu.:133.5   1st Qu.:0.0000   1st Qu.:0.00   1st Qu.:1.000  \n Median :153.0   Median :0.0000   Median :0.80   Median :2.000  \n Mean   :149.6   Mean   :0.3267   Mean   :1.04   Mean   :1.601  \n 3rd Qu.:166.0   3rd Qu.:1.0000   3rd Qu.:1.60   3rd Qu.:2.000  \n Max.   :202.0   Max.   :1.0000   Max.   :6.20   Max.   :3.000  \n```\n\n\n:::\n\n```{.r .cell-code}\n# remove id\nheart_disease = heart_disease[ , !(names(heart_disease) %in% c('id'))]\n\n# scaling data and saving as a data frame\nscaled = scale(heart_disease)\n\n# what does data look like now?\nsummary(scaled)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      age               sex                cp             trestbps       \n Min.   :-2.8145   Min.   :-1.4549   Min.   :-2.2481   Min.   :-2.14149  \n 1st Qu.:-0.7124   1st Qu.:-1.4549   1st Qu.:-0.1650   1st Qu.:-0.66420  \n Median : 0.1727   Median : 0.6851   Median :-0.1650   Median :-0.09601  \n Mean   : 0.0000   Mean   : 0.0000   Mean   : 0.0000   Mean   : 0.00000  \n 3rd Qu.: 0.7259   3rd Qu.: 0.6851   3rd Qu.: 0.8765   3rd Qu.: 0.47218  \n Max.   : 2.4961   Max.   : 0.6851   Max.   : 0.8765   Max.   : 3.88132  \n      chol              fbs             restecg             thalach       \n Min.   :-2.3310   Min.   :-0.4169   Min.   :-0.995103   Min.   :-3.4364  \n 1st Qu.:-0.6894   1st Qu.:-0.4169   1st Qu.:-0.995103   1st Qu.:-0.7041  \n Median :-0.1100   Median :-0.4169   Median : 0.009951   Median : 0.1483  \n Mean   : 0.0000   Mean   : 0.0000   Mean   : 0.000000   Mean   : 0.0000  \n 3rd Qu.: 0.5467   3rd Qu.:-0.4169   3rd Qu.: 1.015005   3rd Qu.: 0.7166  \n Max.   : 6.1283   Max.   : 2.3905   Max.   : 1.015005   Max.   : 2.2904  \n     exang            oldpeak            slope        \n Min.   :-0.6955   Min.   :-0.8954   Min.   :-0.9747  \n 1st Qu.:-0.6955   1st Qu.:-0.8954   1st Qu.:-0.9747  \n Median :-0.6955   Median :-0.2064   Median : 0.6480  \n Mean   : 0.0000   Mean   : 0.0000   Mean   : 0.0000  \n 3rd Qu.: 1.4331   3rd Qu.: 0.4827   3rd Qu.: 0.6480  \n Max.   : 1.4331   Max.   : 4.4445   Max.   : 2.2708  \n```\n\n\n:::\n:::\n\n\n## 3. Let's start grouping patients\n\nOnce we've figured out if we need to modify the data and made any necessary changes, we can now start the clustering process. For the k-means algorithm, it is necessary to select the number of clusters in advance.\n\nIt is also important to make sure that your results are reproducible when conducting a statistical analysis. This means that when someone runs your code on the same data, they will get the same results as you reported. Therefore, if you're conducting an analysis that has a random aspect, it is necessary to set a seed to ensure reproducibility.\n\nReproducibility is especially important since doctors will potentially be using our results to treat patients. It is vital that another analyst can see where the groups come from and be able to verify the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set the seed so that results are reproducible\nseed_val = 10\nset.seed(seed_val)\n\n# select a number of clusters\nk = 5\n\n# run the k-means algorithms\nfirst_clust = kmeans(scaled, centers = k, nstart = 1)\n\n# how many patients are in each group\nfirst_clust$size\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 66 43 88 61 45\n```\n\n\n:::\n:::\n\n\n## 4. Another round of k-means\n\nBecause the k-means algorithm initially selects the cluster centers by randomly selecting points, different iterations of the algorithm can result in different clusters being created. If the algorithm is truly grouping together similar observations (as opposed to clustering noise), then cluster assignments will be somewhat robust between different iterations of the algorithm.\n\nWith regards to the heart disease data, this would mean that the same patients would be grouped together even when the algorithm is initialized at different random points. If patients are not in similar clusters with various algorithm runs, then the clustering method isn't picking up on meaningful relationships between patients.\n\nWe're going to explore how the patients are grouped together with another iteration of the k-means algorithm. We will then be able to compare the resulting groups of patients.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set the seed\nseed_val = 38\nset.seed(seed_val)\n\n# run the k-means algorithms\nk = 5\nsecond_clust = kmeans(scaled, k, nstart=1)\n\n# how many patients are in each group\nsecond_clust$size\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 65 43 61 46 88\n```\n\n\n:::\n:::\n\n\n## 5. Comparing patient clusters\n\nIt is important that the clusters resulting from the k-means algorithm are stable. Even though the algorithm begins by randomly initializing the cluster centers, if the k-means algorithm is the right choice for the data, then different initializations of the algorithm will result in similar clusters.\n\nThe clusters from different iterations may not be exactly the same, but the clusters should be roughly the same size and have similar distributions of variables. If there is a lot of change in clusters between different iterations of the algorithm, then k-means clustering is not a good choice for the data.\n\nIt is not possible to validate that the clusters obtained from an algorithm are ground truth are accurate since there is no true labeling for patients. Thus, it is necessary to examine how the clusters change between different iterations of the algorithm. We're going to use some visualizations to get an idea of the cluster stabilities. That way we can see how certain patient characteristics may have been used to group patients together.\n\nI\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# adding cluster assignments to the data\nheart_disease['first_clust'] = first_clust$cluster\nheart_disease['second_clust'] = second_clust$cluster\n\n# load ggplot2\nlibrary(ggplot2)\n\n# creating the plots of age and chol for the first clustering algorithm\nplot_one = ggplot(heart_disease, aes(x=age, y=chol, color=as.factor(first_clust))) + geom_point()\nplot_one \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# creating the plots of age and chol for the second clustering algorithm\nplot_two = ggplot(heart_disease, aes(x=age, y=chol, color=as.factor(second_clust))) + geom_point()\nplot_two\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\n## 6. Hierarchical clustering: another clustering approach\n\nAn alternative to k-means clustering is hierarchical clustering. This method works well when the data has a nested structure. It is possible that the data from heart disease patients follows this type of structure. For example, if men are more likely to exhibit certain characteristics, those characteristics might be nested inside the gender variable. Hierarchical clustering also does not require the number of clusters to be selected prior to running the algorithm.\n\nClusters can be selected by using the dendrogram. The dendrogram allows one to see how similar observations are to one another and are useful in selecting the number of clusters to group the data. It is now time for us to see how hierarchical clustering groups the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# executing hierarchical clustering with complete linkage\nhier_clust_1 = hclust(dist(scaled), method= 'complete')\n\n# printing the dendrogram\nplot(hier_clust_1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# getting cluster assignments based on number of selected clusters\nhc_1_assign <- cutree(hier_clust_1, 5)\n```\n:::\n\n\n## 7. Hierarchical clustering round two\n\nIn hierarchical clustering, there are multiple ways to measure the dissimilarity between clusters of observations. Complete linkage records the largest dissimilarity between any two points in the two clusters being compared. On the other hand, single linkage is the smallest dissimilarity between any two points in the clusters. Different linkages will result in different clusters being formed.\n\nWe want to explore different algorithms to group our heart disease patients. The best way to measure dissimilarity between patients could be to look at the smallest difference between patients and minimize that difference when grouping together clusters. It is always a good idea to explore different dissimilarity measures. Let's implement hierarchical clustering using a new linkage function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# executing hierarchical clustering with complete linkage\nhier_clust_2 = hclust(dist(scaled), method='single')\n\n# printing the dendrogram\nplot(hier_clust_2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# getting cluster assignments based on number of selected clusters\nhc_2_assign <- cutree(hier_clust_2,5)\n```\n:::\n\n\n## 8. Comparing clustering results\n\nThe doctors are interested in grouping similar patients together in order to determine appropriate treatments. Therefore, they want to have clusters with more than a few patients to see different treatment options. While it is possible for a patient to be in a cluster by themselves, this means that the treatment they received might not be recommended for someone else in the group.\n\nAs with the k-means algorithm, the way to evaluate the clusters is to investigate which patients are being grouped together. Are there patterns evident in the cluster assignments or do they seem to be groups of noise? We're going to examine the clusters resulting from the two hierarchical algorithms.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# adding assignments of chosen hierarchical linkage\nheart_disease['hc_clust'] = hc_1_assign\n\n# remove 'sex', 'first_clust', and 'second_clust' variables\nhd_simple = heart_disease[, !(names(heart_disease) %in% c('sex', 'first_clust', 'second_clust'))]\n\n# getting mean and standard deviation summary statistics\nclust_summary = do.call(data.frame, aggregate(. ~hc_clust, data = hd_simple, function(x) c(avg = mean(x), sd = sd(x))))\nclust_summary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  hc_clust  age.avg   age.sd   cp.avg     cp.sd trestbps.avg trestbps.sd\n1        1 51.41667 8.540979 2.783333 0.9470625     129.1389    15.93800\n2        2 58.11111 7.754246 3.763889 0.6165112     130.0417    13.90657\n3        3 61.00000 3.908034 3.916667 0.2886751     168.5000    17.45904\n4        4 59.00000 9.203580 3.571429 0.8501112     134.7714    18.64070\n5        5 64.75000 2.061553 3.250000 0.5000000     138.7500    18.42779\n  chol.avg  chol.sd   fbs.avg    fbs.sd restecg.avg restecg.sd thalach.avg\n1 239.8722 42.29228 0.1222222 0.3284559   0.8444444  0.9905826    161.5722\n2 253.2222 49.74476 0.1805556 0.3873488   1.4027778  0.9140488    135.5417\n3 284.9167 53.00336 0.3333333 0.4923660   1.2500000  0.9653073    147.7500\n4 233.8571 49.67136 0.1428571 0.3550358   0.6857143  0.9321521    116.8857\n5 433.7500 89.93470 0.2500000 0.5000000   2.0000000  0.0000000    156.2500\n  thalach.sd  exang.avg  exang.sd oldpeak.avg oldpeak.sd slope.avg  slope.sd\n1  15.779214 0.07777778 0.2685686    0.555000  0.7847196  1.388889 0.5730336\n2  17.991342 0.81944444 0.3873488    1.451389  1.0804268  1.750000 0.5240686\n3  13.157266 0.75000000 0.4522670    2.316667  1.4708274  2.166667 0.5773503\n4  17.842071 0.48571429 0.5070926    2.240000  1.3856831  2.200000 0.4058397\n5   3.774917 0.00000000 0.0000000    1.100000  0.3829708  1.500000 0.5773503\n```\n\n\n:::\n:::\n\n\n## 9. Visualizing the cluster contents\n\nIn addition to looking at the distributions of variables in each of the hierarchical clustering run, we will make visualizations to evaluate the algorithms. Even though the data has more than two dimensions, we can get an idea of how the data clusters by looking at a scatterplot of two variables. We want to look for patterns that appear in the data and see what patients get clustered together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plotting age and chol\nplot_one = ggplot(hd_simple, aes(x=age, y=chol, color=as.factor(hc_clust))) + geom_point()\nplot_one \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# plotting oldpeak and trestbps\nplot_two = ggplot(hd_simple, aes(oldpeak, trestbps, color=as.factor(hc_clust))) + geom_point()\nplot_two\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n:::\n\n\n## 10. Conclusion\n\nNow that we've tried out multiple clustering algorithms, it is necessary to determine if we think any of them will work for clustering our patients. For the k-means algorithm, it is imperative that similar clusters are produced for each iteration of the algorithm. We want to make sure that the algorithm is clustering signal as opposed to noise.\n\nFor the sake of the doctors, we also want to have multiple patients in each group so they can compare treatments. We only did some preliminary work to explore the performance of the algorithms. It is necessary to create more visualizations and explore how the algorithms group other variables. Based on the above analysis, are there any algorithms that you would want to investigate further to group patients? Remember that it is important the k-mean algorithm seems stable when running multiple iterations.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}